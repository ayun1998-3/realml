<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="./libraries/ml.min.js"></script>
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
    <title>Brains@Play ML</title>
</head>

<body>
    <div id="startup"></div>
    <div id="readout"></div>
</body>

<script type="module">
    import * as library from './src/index.js'



    // let result = library.ml.sort({ x: [2, 3, 1], y: [4, 6, 2] });
    // console.log('result',JSON.stringify(result))
    // result = {x: [1,2,3], y: [2,4,6]}

    // //data simulation
    // let dataValues = new Array();
    // const simData = library.data.simulate( 
    //         dataValues => {
    //             console.log(dataValues)
    //             const p = document.createElement('p')
    //             p.innerHTML = `${dataValues.slice(-1)}`
    //             readout.insertAdjacentElement('beforeend', p)
    //         })

    // // Get Audio data?
    const start = document.createElement('button')
    start.innerHTML = 'Record Audio'
    const test = document.createElement('button')
    test.innerHTML = 'Test audio real-time'
    startup.insertAdjacentElement('beforeend', start)

    let training1 = [] // contains arrays of length 512, with first < 100 elements being non-zero
    let training2 = []
    const class1 = 'alarm'
    const class2 = 'waves'

    start.onclick = function () {

        // 3s countdown
        library.time.timer(3)

        setTimeout(library.data.simulateAudio, 3000, data => {
            training1.push(data)
        },
            function onSuccess() {
                console.log('audio: ', training1)
                let labels1 = training1.map(x => class1) // generate labels
                let labels2
                console.log(labels1)

                library.time.timer(5) // next trial

                setTimeout(library.data.simulateAudio, 5000,
                    data => {
                        training2.push(data)
                    },
                    function onSuccess() {
                        console.log('audio: ', training2)
                        labels2 = training2.map(x => class2)
                        console.log(labels2)

                        let trainingData = training1.concat(training2)

                        let labels = labels1.concat(labels2)
                        library.ml.trainNN(trainingData, labels)
                        startup.insertAdjacentElement('beforeend', test) // add testing

                    }
                )


            })
    }

    test.onclick = function () {
        library.data.simulateAudio( data => {
            library.ml.testNN(data)
        },
        
        function onSuccess() {})

    }
    


    // // // Data generation
    // const x = Array.from({ length: 1000 }, (v, i) => i * 0.1 + 1)
    // const y = library.data.generate(val => Math.sin(val), x)
    // console.log('y', y)

    // const labels = library.ml.generateLabels(value => (value < 0) ? -1 : 1, y);

    // // // Display
    // y.forEach((v, i) => {
    //     const p = document.createElement('p')
    //     p.innerHTML = `${v},${labels[i]}`
    //     readout.insertAdjacentElement('beforeend', p)
    // })

    // // // Train
    // const xd = library.data.generate2d(val => Math.sin(val), x, 2)
    // const yd = library.ml.generateLabels2d(value => (value < 0) ? 0 : 1, xd)
    // console.log(yd)

    // const type = 'naiveBayes'
    // const model = library.ml[type](xd, yd)
    // console.log(model)

    // // // Test

    // // let results = new Array()
    // // library.data.simulate( (results) => {
    // const xTest = Array.from({ length: 1000 }, (v, i) => i * 0.1 + 1) //random values used

    // let xActual = library.data.generate2d(val => Math.sin(val), xTest, 2)
    // let yActual = library.ml.generateLabels2d(value => (value < 0) ? 0 : 1, xActual)
    // const yPredicted = library.ml.predict(model, xActual)

    // console.log(xActual, yActual, yPredicted)
    // const performance = yPredicted.map((v, i) => v === yActual[i]).reduce((a, b) => a + b) / yPredicted.length
    // console.log('Performance', performance)
// })
</script>

</html>